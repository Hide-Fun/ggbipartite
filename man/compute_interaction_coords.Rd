% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_interaction_coords.R
\name{compute_interaction_coords}
\alias{compute_interaction_coords}
\title{Compute interaction polygon coordinates for a bipartite layout}
\usage{
compute_interaction_coords(.box1, .box2, .interation_cell)
}
\arguments{
\item{.box1}{A data frame/tibble describing the row-side boxes. Must contain
at least a `row` identifier, the x coordinate to join on, and the vertical
span information required by `split_y_by_interaction()`.}

\item{.box2}{A data frame/tibble describing the column-side boxes. Must
contain at least a `column` identifier, the x coordinate to join on, and
the matching vertical span information.}

\item{.interation_cell}{A data frame/tibble of interaction cells (retains the
original argument spelling). Requires, at minimum, the `row`, `column`, and
per-cell interaction size used for splitting.}
}
\value{
A tibble with columns:
\describe{
  \item{\code{row}}{Row identifier.}
  \item{\code{column}}{Column identifier.}
  \item{\code{x}, \code{y}}{Polygon vertex coordinates in CCW order (four rows
                             per \code{row}–\code{column} cell).}
  \item{\code{area}}{Polygon area (repeated across the four vertices of a cell).}
}
}
\description{
Given per-row and per-column box layouts and an interaction-cell table, this
function constructs 4-vertex polygons (one per nonzero interaction cell)
describing the ribbon/rectangle that connects the corresponding row box to
the column box. Each polygon is returned as four points in counter-clockwise
(CCW) order along with its area.
}
\details{
The workflow is:
\enumerate{
  \item Join `.box1` and `.interation_cell`, then call
        \code{split_y_by_interaction(x_side = "xmax", var = "row")} to obtain
        \code{y_start}/\code{y_end} for each \code{row}–\code{column} cell on
        the row side and duplicate the x coordinate into \code{x1}/\code{x2}.
  \item Join `.box2` and `.interation_cell`, then call
        \code{split_y_by_interaction(x_side = "xmin", var = "column")} to obtain
        the analogous \code{y3}/\code{y4} and \code{x3}/\code{x4} for the column side.
  \item Merge both sides, pivot the four vertex columns to long format, and
        reconstruct (x, y) pairs for the 4 vertices.
  \item Order each 4-point set counter-clockwise (\code{\link{order_ccw_df}}),
        compute its area via the shoelace formula
        (\code{\link{polygon_area_xy}}), then unnest.
}
}
\note{
This function relies on an external helper \code{split_y_by_interaction()}
that must exist in scope and return \code{y_start}, \code{y_end}, and \code{x}.
No NA values are permitted in the polygon vertex coordinates.
}
\section{Required inputs}{

\describe{
  \item{`.box1`}{A tibble/data frame describing the \emph{row-side} boxes.
    Must contain at least:
    \itemize{
      \item \code{row}: row identifier (key used to join with `.interation_cell`).
      \item \code{x}: the x coordinate of the row-side vertical edge.
      \item \code{xmin}/\code{xmax} (if present): \code{split_y_by_interaction()}
            may use these; this function passes \code{x_side = "xmax"} when
            splitting the row side.
      \item \code{y} or precomputed vertical extents per row are not required;
            they are produced by \code{split_y_by_interaction()}.
      \item \code{interaction_size}: will be dropped if present.
    }}
  \item{`.box2`}{A tibble/data frame describing the \emph{column-side} boxes.
    Must contain at least:
    \itemize{
      \item \code{column}: column identifier (key used to join).
      \item \code{x}: the x coordinate of the column-side vertical edge.
      \item \code{xmin}/\code{xmax} (if present): \code{split_y_by_interaction()}
            may use these; this function passes \code{x_side = "xmin"} when
            splitting the column side.
      \item \code{interaction_size}: will be dropped if present.
    }}
  \item{`.interation_cell`}{(sic) A tibble/data frame of interaction cells with
    at least \code{row}, \code{column}, and the per-cell "interaction size"
    that \code{split_y_by_interaction()} uses to subdivide vertical spans.
    (The original spelling \code{.interation_cell} is retained to match the
    calling code.)}
}
}

\examples{
\dontrun{
# Minimal example (requires user-defined split_y_by_interaction()):
box1 <- tibble::tibble(row = 1:2, x = 0.0, xmin = 0.0, xmax = 0.4, interaction_size = c(NA, NA))
box2 <- tibble::tibble(column = 1:2, x = 1.0, xmin = 0.6, xmax = 1.0, interaction_size = c(NA, NA))
cells <- tibble::tibble(row = c(1,1,2,2), column = c(1,2,1,2), interaction_size = c(2,1,1,3))
coords <- compute_interaction_coords(box1, box2, cells)
}

}
