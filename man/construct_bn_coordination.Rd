% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bipartite_network.R
\name{construct_bn_coordination}
\alias{construct_bn_coordination}
\title{Construct box and interaction coordinates for a bipartite network}
\usage{
construct_bn_coordination(
  .mat,
  .row,
  .column,
  .metadata_row = NULL,
  .metadata_column = NULL,
  .x0 = 0,
  .y0 = 0,
  .gap = 0,
  .box_ratio = 5,
  .ratio = 1/1.618,
  .adjust_box_height = TRUE
)
}
\arguments{
\item{.mat}{A numeric matrix of interactions; rows and columns represent the
two node sets.}

\item{.metadata_row}{Optional tibble/data frame of row-level metadata to join
to the **row-side** box table (`box1`). Must contain a `row` key that
matches the identifiers used in `.mat`/`bipartite_network()`.}

\item{.metadata_column}{Optional tibble/data frame of column-level metadata to
join to the **column-side** box table (`box2`) and to `interaction_coords`.
Must contain a `column` key that matches the identifiers used in
`.mat`/`bipartite_network()`.}

\item{.x0, .y0}{Numeric scalars; global origin for the left/bottom corner of
the first box.}

\item{.gap}{Non-negative numeric scalar; baseline vertical gap between
adjacent items on each side (subject to adjustment; see \code{.adjust_box_height}).}

\item{.box_ratio}{Positive numeric scalar; divisor to derive per-box width as
\code{sum(.mat) / .box_ratio}.}

\item{.ratio}{Positive numeric scalar; divisor to derive overall width as
\code{sum(.mat) / .ratio}.}

\item{.adjust_box_height}{Logical; if \code{TRUE}, the vertical gaps for each
side are adjusted so that the total heights of the two sides match (uses
\code{\link{calc_global_params}} and its helper).}
}
\value{
A named list with three components:
\describe{
  \item{\code{box1}}{Tibble/data frame of row-side box coordinates.}
  \item{\code{box2}}{Tibble/data frame of column-side box coordinates.}
  \item{\code{interaction_coords}}{Tibble/data frame of CCW-ordered polygon
        vertices (\code{x}, \code{y}) for each \code{row}â€“\code{column}
        interaction, including an \code{area} column.}
}
}
\description{
Given a bipartite interaction matrix, compute:
(1) global layout parameters, (2) per-side box coordinates for rows and
columns, and (3) per-cell interaction polygons connecting the two sides.
Optionally, row/column metadata can be joined onto the resulting frames.
}
\details{
Pipeline:
\enumerate{
  \item \code{\link{bipartite_network}()} produces row/column summaries and a
        long-form interaction table.
  \item \code{\link{calc_global_params}()} computes layout constants (box
        positions, widths, and side-specific gaps).
  \item \code{\link{compute_box_coords}()} builds the boxes for rows
        (\code{.var = "row"}) and columns (\code{.var = "column"}).
  \item \code{\link{compute_interaction_coords}()} constructs a 4-vertex
        polygon for each nonzero interaction cell connecting the two sides.
}

If metadata is supplied:
\itemize{
  \item When both row and column metadata are provided, they are left-joined
        into \code{box1}, \code{box2}, and \code{interaction_coords}
        (first columns, then rows for the latter).
  \item When only one side is provided, it is joined to the corresponding box
        table; \code{interaction_coords} is left unchanged.
}
}
\note{
The function body refers to \code{.metadata_row} and \code{.metadata_column}
(with correct spelling) in the joins, while the arguments are named
\code{.metadata_row} and \code{.metadata_column}. Align these names in your
implementation to avoid runtime errors.

The helper \code{compute_box_coords()} is expected to accept arguments
\code{(.df, .var, .size, .x0, .width, .gap)} and return a data frame with
at least \code{.var}, \code{x}, \code{xmin}, \code{xmax}, and vertical span
information used downstream.
}
\examples{
\dontrun{
m <- matrix(c(2, 1, 0,
              0, 3, 2), nrow = 2, byrow = TRUE)

# Optional metadata (must contain `row` / `column` keys)
row_meta <- tibble::tibble(row = 1:2, group = c("A", "B"))
col_meta <- tibble::tibble(column = 1:3, type = c("x","y","z"))

res <- construct_bn_coordination(
  .mat = m,
  .metadata_row = row_meta,
  .metadata_column = col_meta,
  .x0 = 0, .y0 = 0,
  .gap = 0.1,
  .box_ratio = 5,
  .ratio = 1 / 1.618,
  .adjust_box_height = TRUE
)
str(res$box1); str(res$box2); str(res$interaction_coords)
}

}
\seealso{
\code{\link{bipartite_network}}, \code{\link{calc_global_params}},
  \code{\link{compute_box_coords}}, \code{\link{compute_interaction_coords}}
}
